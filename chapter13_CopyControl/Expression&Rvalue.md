# 右值引用：从表达式讲起

## 什么是表达式

表达式是由数字，运算符，函数等组成的代码片段。

常见有以下几种表达式：

+ 算术表达式

```c++
int res = 2 + 3 * 4;
```

> 整条代码可算做一个表达式，它由等号左边和等号右边组成

+ 赋值表达式

```c++
int x = 114514;
x += 1919810;
x++;
```

> 辨析： `++x` 和 `x++`
>  
> 我认为，是`前缀递增运算符` 和 `后缀递增运算符` 这两种运算符的区别导致了 `x++` 与 `++x` 成为了两种不同的表达式
>
> + `++x` 是 **递增表达式**，它递增x的值。这是个唯一的表达式。同时多项时，先执行这条表达式，之后再考虑其他
> + `x++` 是 **赋值表达式**，当其他变量要接受 `x` 的时候，先交出 `x`，之后再递增 `x`
>
> 上述两表达式操作原理不同，所以生成的汇编程序可能不同

+ 函数调用表达式

```c++
int res = max(114, 514);
```

+ 条件表达式

```c++
int res = (x == 114) ? 514 : 1919810;
```

## 表达式的另一种分类方式：左值，右值

可以二元的将表达式分成 `左值表达式` 和 `右值表达式`：

```c++
int res = 2 + 3 * 4;
```

如上，`res`为**左值**，等号右侧 `2 + 3 * 4` 为**右值**
特殊例外较多，所以我们区分他们的方式主要是看：

+ 左值常被用作对象的身份(在内存中的位置)
+ 右值常被用作对象的值(仅表示对象包含的信息)

对于常规引用，可以看作是创建对象的别名，可称为左值引用，而右值引用则是直接引用对象的值，仅此而已

```c++
int a = 42;
int &p = a; // p:对象引用
/* 语法:左绑定到右 */
int &&r1 = a; // 错误:右值应用无法绑到左值上
int &p1 = a * 114; // 错误:右值无法绑到左值上
int &&r2 = a * 114; // 正确，右值引用
const int &p2 = a * 114; // 可以将const引用绑定到右值上
```

+ `const` 引用绑定右值
从生命周期看，左值可以根据使用方式而改变，但右值生命周期仅存在于语句内部
可以使用 `const` 引用绑定右值来延长右值表达式的生命周期：

```c++
int main() {
    int a = 42;
    const int &p2 = a * 114;
}
```

```asm
/* x86_64 clang 14.0.0 */
main:                                   # @main
        push    rbp
        mov     rbp, rsp
        mov     dword ptr [rbp - 4], 42       ; 42存入变量a,位置 [rbp - 4]
        imul    eax, dword ptr [rbp - 4], 114 ; 值114与变量相乘存入eax
        mov     dword ptr [rbp - 20], eax     ; 移入 位置[rbp - 20]
        lea     rax, [rbp - 20]               ; 存至 rax
        mov     qword ptr [rbp - 16], rax
        xor     eax, eax
        pop     rbp
        ret
```

可以看到，存在这条指令：`lea  rax, [rbp - 20]`
编译器会将将右值计算并存储，就像普通变量那样。
为什么呢？因为 `const` 引用符合右值的性质，二者部分性质互通。

右值表现为不可修改的临时数据，而 `const` 引用也表现为：

+ 临时数据(引用)
+ 不可修改( `const` )

因此可以将常量引用与右值绑定起来。

> 谈及延长右值生命周期，除与const引用绑定外，还可采用**移动语义(move semantics)**

左值，右值属于抽象的广泛概念，我们将其具象化：

变量是左值，临时量属于右值
变量持久，离开作用域才被销毁，右值短暂，离开表达式销毁，它像是运算过程中产生的中间信息

综上，**左值持久，右值短暂**

## 为何使用右值引用？

+ 避免拷贝，增强效率
+ 为控制临时量生命周期提供解决方案
+ 优化拷贝构造函数，如 `string s("hello world");`

## 移动语义

移动语义，即通过使用 std::move 来转移对象的数据所有权的过程
可以说，我们将被移动对象当成右值，将其内部的数据所有权转移到新变量之中。
被移动后，原变量失去所有权，此时开始不应访问原变量，否则UB

该操作本质**将源对象的内部数据指针转移到目标对象**

该操作一般步骤有三：

1. 目标对象准备接收数据。目标对象释放其当前拥有的资源，为新数据腾出空间
2. 移动构造函数的调用。移动构造函数从源对象中获取数据，并将其转移到目标对象中
3. 源对象的状态变为有效但未指定。

> 例外： `Trivially Copyable Type` 对象
>
> 该类型对象可以通过简单的位拷贝进行复制。
> 当该对象被移动时，其内部的Trivially Copyable成员将被直接拷贝到目标对象中，而不会改变其值
> 移动操作只是简单地将其值从源对象复制到目标对象，而不会对其进行其他的构造或析构操作
>  
> 比如下面例子中的 `int` 成员，就属于 `Trivially Copyable Type`
> 但并非所有类型都是 `Trivially Copyable Type`
> 例如，如果一个类包含指针成员或包含了自定义的构造函数、析构函数、拷贝构造函数或移动构造函数等，那么它就不再是Trivially Copyable Type，
> 此时移动操作将涉及到更复杂的操作

```c++
struct Obj {
public:
    int i; // Trivially Copyable Type
    std::string s; // contains move ctor
    std::vector<int> v; // also contains move ctor
};

int main() {
    Obj a1;
    a1.s = "hello";
    a1.i = 114514;
    a1.v = {1, 9, 1, 9, 8, 1, 0};
    Obj a2 = std::move(a1);
}
```

采用GDB进行调试观察：

```gdb
Breakpoint 1, main () at */C++primer/main.cpp:33
33     Obj a2 = std::move(a1);
(gdb) print a1.s
$1 = "hello"
(gdb) print a1.i
$2 = 114514
(gdb) print a1.v
$3 = std::vector of length 7, capacity 7 = {1, 9, 1, 9, 8, 1, 0}

(gdb) continue
Continuing.

Breakpoint 2, main () at */C++primer/main.cpp:34
34  }
(gdb) print a1.v
$5 = std::vector of length 0, capacity 0
(gdb) print a1.i
$6 = 114514
(gdb) print a1.s
$7 = ""
```

与此前描述相符，Q.E.D

## 移动构造函数

```c++
struct Obj {
public:
    Obj(Obj &&rhs) noexcept;
};
```

首先，抛开自定义移动构造函数，在：

+ 自行定义(显式定义)析构函数，或拷贝赋值运算符，或拷贝构造函数
+ 删除或不可可访问移动构造函数，移动赋值运算符

以上两种情况时需要手动自定义移动构造函数，其余情况编译器会自动生成移动构造函数

```c++
struct Obj {
public:
    Obj() = default;
    Obj(const Obj &rhs) { std::cout << "copy ctor called!\n"; }
};

int main() {
    Obj a1;
    Obj a2 = std::move(a1);
}
```

上述情况中，我们自定义了拷贝构造函数，合成移动构造函数被标记为删除，编译器不会生成
因此，我们在 `move` 时，发生了右值转换成 `const` 左值引用的情况

